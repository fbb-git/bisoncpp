#define COPT               "-O2"

#define ECHO_REQUEST       1

#define LIBS               "bobcat"
#define LIBPATH            ""


string                  // contain options for
    g_copt,             // Compiler options
    g_cwd,              // current WD
    libs,               // extra libs, e.g., "-lrss -licce"
    libpath,            // extra lib-paths, eg, "-L../rss"
    g_sources,          // sources to be used
    g_binary;           // the name of the program to create
int
    g_base,
    g_nClasses;         // number of classes/subdirectories
list
    g_classes,          // list of classes/directories
    g_classLines,       // list of all lines in CLASSES
    g_inspected;        // list of classes whose dependencies have been 
                        // inspected (used with USE_ALL)

/*
    if a class has an a file, then that file is removed and all 
    classes depending on that class are determined and compiled
*/

string setOpt(string install_im, string envvar)
{
    list optvar;
    string ret;

    optvar = getenv(envvar);    

    if (optvar[0] == "1")
        ret = optvar[1];
    else 
        ret = install_im;

    return ret;
}

int find(string needle, list haystack)
{
    int idx;
    for (idx = sizeof(haystack); idx--; )
    {
        if (needle == haystack[idx])
            break;
    }
    return idx;
}

void touch(string dir)
{
    echo(OFF);
    if (!exists(dir + "/a"))
        system("touch " + dir + "/a");
    echo(ON);
}
            
    //  g_classes[idx] has 'a' set. 
    //  find all classes that depend on g_classes[idx], 
    //  if those classes haven't been inspected yet, then set their 'a'
    //  file and inspect their dependencies.
void dependendenciesOf(string thisClass)
{
    int ret;
    int idx;
    string classLine;
    string hit;

    if (find(thisClass, g_inspected) != -1) // this class already inspected
        return;                             // then done with this class

    g_base = 1;                             // recompile the base's files

    printf("RECOMPILE: ", thisClass, "\n");
    g_inspected += (list)thisClass;         // now inspected

        // find all classes depending on thisClass
    for (idx = 0; idx != g_nClasses; ++idx)
    {
        classLine = g_classLines[idx];

        if (strfind(classLine, thisClass) > 0)
        {
            hit = strtok(classLine, " \t")[0];
            touch(hit);
            dependendenciesOf(hit);
        }
    }
}               
    
void checkALL()
{
    int idx;
    string all;

    for (idx = 0; idx != g_nClasses; ++idx)
    {
        all = g_classes[idx] + "/a";

        if (exists(all))
            dependendenciesOf(g_classes[idx]);
    }

    if (g_base)
        touch(".");
}
    
void setClasses()
{
    list candidate;
    list class;

    while (sizeof(class = fgets("CLASSES", (int)class[1])))
    {
        candidate = strtok(class[0], " \t\n");

        // if the line contains info not starting with #, add the class
        if (sizeof(candidate) && candidate[0][0] != "#")
        {
            g_classLines += (list)class[0];
            g_classes += (list)element(0, strtok(class[0], " \t\n"));
        }
    }
    g_nClasses = sizeof(g_classes);
    checkALL();
}

void static_lib(string ofiles, string library)
{
    if (sizeof(makelist(ofiles)))
    {
        run("ar cru tmp/" + library + " " + ofiles);
        run("ranlib " + library);
        run("rm -f " + ofiles);
    }
}

void static_library(string library)
{
    static_lib("*/o/*.o", library);
    static_lib("o/*.o", library);
}

void scanner()
{
    int idx;
    list names;
    string file;

    chdir("scanner");
    names = makelist("inc/*");
    names += (list)"lexer";

    for (idx = sizeof(names); idx--; )
    {
        file = names[idx];

        if 
        (                                          // new lexer needed
            exists(file)
            &&
            file younger "lex.cc"
        )
            break;
    }

    if 
    (
        idx >= 0
        ||
        "../parser/parse.cc" younger "lex.cc"
    )
        exec("flexc++", "lexer");

    chdir("..");
}

void parser()
{
    list pFiles;
    int idx;

    chdir("parser");

    pFiles = (list)"grammar" + makelist("inc/*");
    for (idx = sizeof(pFiles); idx--; )
    {
        if (pFiles[idx] younger "parse.cc")
        {
            exec("bisonc++", "-V -l", "grammar");
            break;
        }
    }
    chdir("..");
}

/*
                                I N I T I A L . I M
*/
void initialize()
{
    echo(ECHO_REQUEST);
    g_sources = "*.cc";

    g_cwd = chdir(".");

    parser();
    // scanner(); // we now rely on the generated files.

    setClasses();                           // remaining classes
}

/*
                        L I N K . I M
*/

list inspect(int all, int prefix, list srcList, string library)
{
    int idx;
    string ofile;
    string oprefix;
    string file;
    
    oprefix = "./o/" + (string)prefix;

    for (idx = sizeof(srcList); idx--; )
    {
        file  = srcList[idx];
        ofile   = oprefix + change_ext(file, "o");    // make o-filename

        // A file s must be recompiled if it's newer than its object
        // file o or newer than its target library l, or if neither o nor l
        // exist.
        // Since `a newer b' is true if a is newer than b, or if a exists and
        // b doesn't exist s must be compiled if s newer o and s newer l.
        // So, it doesn't have to be compiled if s older o or s older l.
                                            // redo if file has changed
        if (file older ofile || (all == -1 && file older library))
            srcList -= (list)file;

        // compile all files unless already compiled

    }
    return srcList;
}


void c_compile(int prefix, string srcDir, list cfiles)
{
    int idx;
    string compiler;
    string file;

    compiler = COMPILER + " -c -o " + srcDir + "/o/" + (string)prefix;

    md(srcDir + "/o");

    for (idx = sizeof(cfiles); idx--; )
    {
        file = cfiles[idx];

        run(compiler + change_ext(file, "o") + " " +
                g_copt + " " + srcDir + "/" + file);
    }
}

void std_cpp(int prefix, string srcDir, string library)
{
    list files;

    chdir(srcDir);

                                                    // make list of all files
    files = inspect(find(srcDir, g_inspected), prefix, makelist(g_sources), 
                                                        library);
    chdir(g_cwd);

    if (sizeof(files))
        c_compile(prefix, srcDir, files);           // compile files
}

void cpp_make(string mainfile, string library, int lib_only)
{
    int idx;
    string class;
    string fullLibname;

    fullLibname = "lib" + library + ".a";

    for (idx = g_nClasses; idx--; )
        std_cpp(idx, g_classes[idx], "../" + fullLibname);

    if (g_base)
        c_compile(g_nClasses, ".", (list)mainfile);

    if (!lib_only)                          // compile all files in current dir
        std_cpp(g_nClasses, ".", fullLibname);

    static_library(fullLibname);            // make the library

    echo(OFF);
    system("rm -f */a");
    echo(ON);
}

void setlibs()
{
    int n;
    int index;
    list cut;

    cut = strtok(LIBS, " ");        // cut op libraries
    n = sizeof(cut);
    for (index = 0; index < n; index++)
        libs += " -l" + element(index, cut);

    cut = strtok(LIBPATH, " ");     // cut up the paths
    n = sizeof(cut);
    for (index = 0; index < n; index++)
        libpath += " -L" + element(index, cut);
}

void library(int lib_only)
{
    initialize();
    setlibs();

    md("tmp/bin tmp/o");

    special();

    g_copt = setOpt(CXXFLAGS, "CXXFLAGS");

    cpp_make
    (
        "bisonc++.cc",
        "bisonc++",         // static program library base name
        lib_only            // don't compile maindir for lib construction
    );

    if (lib_only)
        exit(0);
}






