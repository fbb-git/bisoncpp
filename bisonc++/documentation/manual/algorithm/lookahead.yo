The B() parser does em(not) always reduce immediately as soon as the last
tt(n) tokens and groupings match a rule. This is because such a simple
strategy is inadequate to handle most languages. Instead, when a reduction is
possible, the parser sometimes "looks ahead" at the next token in order to
decide what to do.

When a token is read, it is not immediately shifted; first it becomes the
em(look-ahead) token, which is not on the stack. Now the parser can perform
one or more reductions of tokens and groupings on the stack, while the
look-ahead token remains off to the side. When no more reductions should take
place, the look-ahead token is shifted onto the stack. This does not mean that
all possible reductions have been done; depending on the token type of the
look-ahead token, some rules may choose to delay their application.

Here is a simple case where look-ahead is needed. These three rules define
expressions which contain binary addition operators and postfix unary
factorial operators (`tt(!)'), and allow parentheses for grouping.
    verb(
    expr:     
        term '+' expr
    | 
        term
    ;

    term:     
        '(' expr ')'
    | 
        term '!'
    | 
        NUMBER
    ;
        )
    Suppose that the tokens `tt(1 + 2)' have been read and shifted; what
should be done? If the following token is `CLOSEPAR', then the first three
tokens must be reduced to form an tt(expr). This is the only valid course,
because shifting the `CLOSEPAR' would produce a sequence of symbols term
'CLOSEPAR', and no rule allows this.

If the following token is `tt(!)', then it must be shifted immediately so that
`tt(2 !)' can be reduced to make a term. If instead the parser were to reduce
before shifting, `tt(1 + 2)' would become an tt(expr). It would then be
impossible to shift the `tt(!)' because doing so would produce on the stack
the sequence of symbols expr 'tt(!)'. No rule allows that sequence.

The current look-ahead token is stored in the parser's private data member
tt(d_token). However, this data member is not normally modified by member
functions not generated by B(). See section ref(SPECIAL).

