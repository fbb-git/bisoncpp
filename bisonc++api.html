<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>bisonc++api</title>
<style type="text/css">
    body {color: #27408B; background: #FFFAF0;}
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body>
<hr/>
<h1 id="title">bisonc++api</h1>
<h2 id="author">bisonc++.5.02.01.tar.gz</h2>
<h2 id="date">2005-2016</h2>

<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<style type="text/css">
    body {color: #27408B; background: #FFFAF0;}
    figure {text-align: center;}
    img {vertical-align: center;}
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body>
<hr/>
<h1 id="title"></h1>

<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>bisonc++api(3)</title>
<style type="text/css">
    body {color: #27408B; background: #FFFAF0;}
    figure {text-align: center;}
    img {vertical-align: center;}
    figure {text-align: center;}
    img {vertical-align: center;}
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body>
<hr/>
<h1 id="title">bisonc++api(3)</h1>
<h2 id="author">bisonc++.5.02.01.tar.gz bisonc++ API</h2>
<h2 id="date">2005-2016</h2>


<p>

<h2 >NAME</h2>bisonc++ - Application programmer's interface of bisonc++ generated classes
<p>
<h2 >DESCRIPTION</h2>
<p>
<strong >Bisonc++</strong> derives from <strong >bison++</strong>(1), originally derived from
<strong >bison</strong>(1). Like these programs <strong >bisonc++</strong> generates a parser for an LALR(1)
grammar. <strong >Bisonc++</strong> generates <strong >C++</strong> code: an expandable <strong >C++</strong> class.
<p>
Refer to <strong >bisonc++</strong>(1) for a general overview. This manual page covers the
application programmer's interface of classes generated by <strong >bisonc++</strong>. It contains
the following sections:
<p>
<ul>
    <li> <strong >DESCRIPTION</strong>: this section;
    <li> <strong >PUBLIC MEMBERS AND -TYPES</strong>: members and types that can be used
           by calling software;
    <li> <strong >PRIVATE ENUMS AND -TYPES</strong>: enumerations and types only
           available to the <em >Parser</em> class;
    <li> <strong >PRIVATE MEMBER FUNCTIONS</strong>: member functions that are only
           available to the <em >Parser</em> class;
    <li> <strong >PRIVATE DATA MEMBERS</strong>: data members that are only available to
           the <em >Parser</em> class;
    <li> <strong >TYPES AND VARIABLES IN THE ANONYMOUS NAMESPACE</strong>: an overview of
           the types and variables that are used to define and store the
           grammar-tables generated by <strong >bisonc++</strong>;
    <li> <strong >SEE ALSO</strong>: references to other programs and documentation;
    <li> <strong >AUTHOR</strong>: at the end of this man-page.
    </ul>
<p>
<h2 >PUBLIC MEMBERS, TYPES, AND ENUMS</h2>
<p>
    Parser classes generated by <strong >bisonc++</strong> offer the following public members and
types (in the following overview parser class-name prefixes (e.g.,
<em >Parser::</em>) prefixes were omitted):
    <ul>
    <li> <strong >DebugMode__</strong>:<br/> 
       The values of this <em >enum</em> are used to configure the type of debug
        information that will be displayed (assuming that the <em >debug</em>
        option/directive was specified when <strong >bisonc++</strong> generated the parser's
        code). It has three values:
<p>
<em >OFF</em>: no debug information is displayed when the generated
        parser's <em >parse</em> function is called;
<p>
<em >ON</em>: extensive debug information about the parsing process is
        displayed when the generated parser's <em >parse</em> function is called;
<p>
<em >ACTIONCASES</em>: just before executing the grammar's action blocks
        the action block number is written to the standard output
        stream. These action block numbers refer to  case labels of the switch
        that is defined in the parser's <em >executeAction</em> function. It is
        commonly used to find the action block where a fatal semantic value
        mismatch was observed.
<p>
The <em >bit_or</em> operator can be used to combine <em >ON</em> and
        <em >ACTIONCASES</em> (see the member function <em >setDebug(DebugMode__
        mode)</em> below).
<p>
<li> <strong >LTYPE__</strong>:<br/> 
           The parser's location type (user-definable). Available only when
            either <em >%lsp-needed, %ltype</em> or <em >%locationstruct</em> has been
            declared. 
<p>
<li> <strong >STYPE__</strong>:<br/>
            The parser's stack-type (user-definable), defaults to <strong >int</strong>.
<p>
<li> <strong >Tokens__</strong>:<br/>
           The enumeration type of all the symbolic tokens defined in the
            grammar file (i.e., <strong >bisonc++</strong>'s input file). The scanner should be
            prepared to return these symbolic tokens. Note that, since the
            symbolic tokens are defined in the parser's class and not in the
            scanner's class, the lexical scanner must prefix the parser's
            class name to the symbolic token names when they are
            returned. E.g., <em >return Parser::IDENT</em> should be used rather
            than <em >return IDENT</em>.
<p>
<li> <strong >int parse()</strong>:<br/>
           The parser's parsing member function. It returns 0 when parsing was
            successfully completed; 1 if errors were encountered while parsing
            the input.
<p>
<li> <strong >void setDebug(bool mode)</strong>:<br/>
       This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is always defined but is only
        operational if the <em >debug</em> directive option was specified when <strong >bisonc++</strong>
        generated the <em >parse</em> function. If so, it is <em >not</em> active by
        default; to activate the debug output call <em >setDebug(true)</em>, to
        suppress the debug output call <em >setDebug(false)</em>.
<p>
<li> <strong >void setDebug(DebugMode__ mode)</strong>:<br/>
       This member can also be used to activate or deactivate the debug-code
        compiled into the parsing function. Like <em >setDebug(bool)</em> it is
        always defined but only operational if the <em >debug</em> directive option
        was specified when <strong >bisonc++</strong> generated the <em >parse</em> function. If so, it
        is <em >not</em> active by default; to activate, call
        <em >setDebug(Parser::ON), setDebug(Parser::ACTIONCASES)</em>, or 
        <em >setDebug(Parser::ON | Parser::ACTIONCASES)</em>. To suppress the
        debug code output call <em >setDebug(Parser__::OFF)</em> or simply
        <em >setDebug(false)</em>.
    </ul>
<p>
When the <em >%polymorphic</em> directive is used:
    <ul>
    <li> <strong >Meta__</strong>:<br/>
           Templates and classes that are required for implementing the
            polymorphic semantic values are all declared in the <em >Meta__</em>
            namespace. The <em >Meta__</em> namespace itself is nested under the
            namespace that may have been declared by the <em >%namespace</em>
            directive.
<p>
<li> <strong >Tag__</strong>:<br/>
           The (strongly typed) <em >enum class Tag__</em> contains all the
            tag-identifiers specified by the <em >%polymorphic</em> directive. It is
            declared outside of the Parser's class, but within the namespace
            that may have been declared by the <em >%namespace</em> directive.
    </ul>
<p>
<h2 >PRIVATE ENUMS AND -TYPES</h2>
<p>
    The following enumerations and types can be used by members of parser
classes generated by <strong >bisonc++</strong>. They are actually protected members inherited from
the parser's base class.
    <ul>
    <li> <strong >Base::ErrorRecovery__</strong>:<br/>
        This enumeration defines two values:
        <pre>

    DEFAULT_RECOVERY_MODE__,
    UNEXPECTED_TOKEN__
        
</pre>

       The <em >DEFAULT_RECOVERY_MODE__</em> terminates the parsing process. The
        non-default recovery procedure is available once an <em >error</em> token is
        used in a production rule. When the parsing process throws
        <em >UNEXPECTED_TOKEN__</em> the recovery procedure is started (i.e., it is
        started whenever a syntactic error is encountered or 
        <em >ERROR</em><em >()</em> is called). 
<p>
The recovery procedure consists of (1) looking for the first state on
        the state-stack having an error-production, followed by (2) handling
        all state transitions that are possible without retrieving a terminal
        token. Then, in the state requiring a terminal token and starting with
        the initial unexpected token (3) all subsequent terminal tokens are
        ignored until a token is retrieved which is a continuation token in
        that state. 
<p>
If the error recovery procedure fails (i.e., if no acceptable token is
        ever encountered) error recovery falls back to the default recovery
        mode (i.e., the parsing process is terminated).
<p>
<li> <strong >Base::Return__</strong>:<br/>
        This enumeration defines two values:
        <pre>

    PARSE_ACCEPT = 0,
    PARSE_ABORT = 1
        
</pre>

        (which are of course the <em >parse</em> function's return values).
     </ul>
<p>
When the <em >%polymorphic</em> directive is used:
    <ul>
    <li> <strong >Meta__::sizeofTag__</strong>:<br/>
           <em >sizeofTag__</em> defines the number of tags that were defined for 
            polymorphic semantic values.
    </ul>
<p>
<h2 >PRIVATE MEMBER FUNCTIONS</h2>
<p>
    The following members can be used by members of parser classes generated
by <strong >bisonc++</strong>. When prefixed by <em >Base::</em> they are actually protected members
inherited from the parser's base class.  Members for which the phrase ``Used
internally'' is used should not be called by user-defined code.
    <ul>
    <li> <strong >Base::ParserBase()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::ABORT() const throw(Return__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to indicate a failure while parsing thus
        terminating the parsing function with an error value 1. Note that this
        offers a marked extension and improvement of the macro <em >YYABORT</em>
        defined by <strong >bison++</strong> in that <em >YYABORT</em> could not be called from
        outside of the parsing member function.
<p>
<li> <strong >void Base::ACCEPT() const throw(Return__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to indicate successful parsing and thus
        terminating the parsing function. Note that this offers a marked
        extension and improvement of the macro <em >YYACCEPT</em> defined by
        <strong >bison++</strong> in that <em >YYACCEPT</em> could not be called from outside of
        the parsing member function.
<p>
<li> <strong >void Base::clearin()</strong>:<br/>
       This member replaces <strong >bison</strong>(++)'s macro <em >yyclearin</em> and causes
        <strong >bisonc++</strong> to request another token from its <em >lex()</em> member,
        even if the current token has not yet been processed. It is a useful
        member when the parser should be reset to its initial state, e.g.,
        between successive calls of <em >parse</em>. In this situation the scanner
        must probably be reloaded with new information as well.
<p>
<li> <strong >bool Base::debug() const</strong>:<br/>
       This member returns the current value of the debug variable.
<p>
<li> <strong >void Base::ERROR() const throw(ErrorRecovery__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to generate an error, and results in the
        parser executing its error recovery code. Note that this offers a
        marked extension and improvement of the macro <em >YYERROR</em> defined by
        <strong >bison++</strong> in that <em >YYERROR</em> could not be called from outside of
        the parsing member function.
<p>
<li> <strong >void error(char const *msg)</strong>:<br/>
      By default implemented inline in the <em >parser.ih</em> internal header file,
       it writes a simple message to the standard error stream. It is called
       when a syntactic error is encountered, and its default implementation
       may safely be altered.
<p>
<li> <strong >void errorRecovery__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::errorVerbose__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void exceptionHandler__(std::exception const &amp;exc)</strong>:<br/>
       This member's default implementation is provided inline in the
        <em >parser.ih</em> internal header file. It consists of a mere <em >throw</em>
        statement, rethrowing a caught exception.
<p>
The <em >parse</em> member function's body essentially consists of a
        <em >while</em> statement, in which the next token is obtained via the
        parser's <em >lex</em> member. This token is then processed according to the
        current state of the parsing process. This may result in executing
        actions over which the parsing process has no control and which may
        result in exceptions being thrown.
<p>
Such exceptions do not necessarily have to terminate the parsing
        process: they could be thrown by code, linked to the parser, that
        simply checks for semantic errors (like divisions by zero) 
        throwing exceptions if such errors are observed.
<p>
The member <em >exceptionHandler__</em> receives and may handle such
        exceptions without necessarily ending the parsing process. It receives
        any <em >std::exception</em> thrown by the parser's actions, as though the
        action block itself was surrounded by a <em >try ... catch</em> statement.
        It is of course still possible to use an explicit <em >try ... catch</em>
        statement within action blocks. However, <em >exceptionHandler__</em> can
        be used to factor out code that is common to various action blocks.
<p>
The next example shows an explicit implementation of
        <em >exceptionHandler__</em>: any <em >std::exception</em> thrown by the parser's
        action blocks is caught, showing the exception's message, and
        increasing the parser's error count. After this parsing continues as
        if no exception had been thrown:
        <pre>

void Parser::exceptionHandler__(std::exception const &amp;exc)
{
    std::cout &lt;&lt; exc.what() &lt;&lt; '\n';
    ++d_nErrors__;
}
        
</pre>

<p>
<strong >Note:</strong> Parser-class header files (e.g., Parser.h) and parser-class
    internal header files (e.g., Parser.ih) generated with <strong >bisonc++</strong> &lt; 4.02.00
    require two small hand-modifications when using <strong >bisonc++</strong> &gt;= 4.02.00:
<p>
In Parser.h, just below the declaration 
        <pre>

void print__();
    
</pre>

    add:
    <pre>

void exceptionHandler__(std::exception const &amp;exc);
    
</pre>

<p>
In Parser.ih, assuming the name of the generated class is `Parser', add the
    following member definition (if a namespace is used: within the
    namespace's scope):
        <pre>

inline void Parser::exceptionHandler__(std::exception const &amp;exc)
{
    throw;  // re-implement to handle exceptions thrown by actions
}
    
</pre>

<p>
<li> <strong >void executeAction(int)</strong>:<br/>
       Used internally.
<p>
<li> <strong >int lex()</strong>:<br/>
      By default implemented inline in the <em >parser.ih</em> internal header file,
       it can be pre-implemented by <strong >bisonc++</strong> using the <em >scanner</em> option or
       directive (see above); alternatively it <em >must</em> be implemented by the
       programmer. It interfaces to the lexical scanner, and should return the
       next token produced by the lexical scanner, either as a plain character
       or as one of the symbolic tokens defined in the <em >Parser::Tokens__</em>
       enumeration. Zero or negative token values are interpreted as `end of
       input'.
<p>
<li> <strong >int lookup(bool)</strong>:<br/>
       Used internally.
<p>
<li> <strong >void nextToken()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::pop__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::popToken__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void print__()()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void print()</strong>:<br/>
      By default implemented inline in the <em >parser.ih</em> internal header file,
       this member calls <em >print__</em> to display the last received token and
       corrseponding matched text. The <em >print__</em> member is only implemented
       if the <em >--print-tokens</em> option or <em >%print-tokens</em> directive was
       used when the parsing function was generated. Calling <em >print__</em> from
       <em >print</em> is unconditional, but can easily be controlled by the using
       program, by defining, e.g., a command-line option.
<p>
<li> <strong >void Base::push__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::pushToken__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::reduce__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::symbol__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::top__()</strong>:<br/>
       Used internally.
    </ul>
<p>
<h2 >PRIVATE DATA MEMBERS</h2>
<p>
The following data members can be used by members of parser classes
generated by <strong >bisonc++</strong>. All data members are actually protected
members inherited from the parser's base class. 
    <ul>
    <li> <strong >size_t d_acceptedTokens__</strong>:<br/>
       Counts the number of accepted tokens since the start of the <em >parse()</em>
        function or since the last detected syntactic error. It is initialized
        to <em >d_requiredTokens__</em> to allow an early error to be detected as
        well. 
    <li> <strong >bool d_actionCases__</strong>:<br/>
       When the <em >debug</em> option has been specified, this variable (<em >false</em>
        by default) determines whether the number of action block which is
        about to be executed by the parser's member <em >executeAction</em> will be
        displayed to the standard output stream.
    <li> <strong >bool d_debug__</strong>:<br/>
       When the <em >debug</em> option has been specified, this variable (<em >true</em>
        by default) determines whether debug information is actually
        displayed.
    <li> <strong >LTYPE__ d_loc__</strong>:<br/>
       The location type value associated with a terminal token. It can be
        used by, e.g., lexical scanners to pass location information of a
        matched token to the parser in parallel with a returned token. It is
        available only when <em >%lsp-needed, %ltype</em> or <em >%locationstruct</em> has
        been defined. <br/>
       Lexical scanners may be offered the facility to assign a value to this
        variable in parallel with a returned token. In order to allow a
        scanner access to <em >d_loc__</em>, <em >d_loc__</em>'s address should be passed
        to the scanner. This can be realized, for example, by defining a
        member <em >void setLoc(STYPE__ *)</em> in the lexical scanner, which is
        then called from the parser's constructor as follows:
       <pre>

            d_scanner.setSLoc(&amp;d_loc__);
       
</pre>

       Subsequently, the lexical scanner may assign a value to the parser's
        <em >d_loc__</em> variable through the pointer to <em >d_loc__</em> stored inside
        the lexical scanner.
    <li> <strong >LTYPE__ d_lsp__</strong>:<br/>
       The location stack pointer.
        Do not modify.
    <li> <strong >size_t d_nErrors__</strong>:<br/>
       The number of errors counted by <em >parse</em>. It is initialized by the
        parser's base class initializer, and is updated while <em >parse</em>
        executes. When <em >parse</em> has returned it contains the total number
        of errors counted by <em >parse</em>. Errors are not counted if suppressed
        (i.e., if <em >d_acceptedTokens__</em> is less than <em >d_requiredTokens__</em>).
    <li> <strong >size_t d_nextToken__</strong>:<br/>
       A pending token. 
        Do not modify.
    <li> <strong >size_t d_requiredTokens__</strong>:<br/>
       Defines the minimum number of accepted tokens that the <em >parse</em>
        function must have processed before a syntactic error can be
        generated. 
    <li> <strong >int d_state__</strong>:<br/>
       The current parsing state. 
        Do not modify.
    <li> <strong >int d_token__</strong>:<br/>
       The current token.
        Do not modify.
    <li> <strong >STYPE__ d_val__</strong>:<br/>
       The semantic value of a returned token or nonterminal symbol. With
        nonterminal tokens it is assigned a value through the action rule's
        symbol <em >$$</em>. Lexical scanners may be offered the facility to assign
        a semantic value to this variable in parallel with a returned
        token. In order to allow a scanner access to <em >d_val__</em>,
        <em >d_val__</em>'s address should be passed to the scanner. This can be
        realized, for example, by passing <em >d_val__</em>'s address to the lexical
        scanner's constructor.
<p>
Subsequently, the lexical scanner may assign a value to the parser's
        <em >d_val__</em> variable through the pointer to <em >d_val__</em> stored in a
        data member of the lexical scanner.
<p>
Note that in some cases this approach <em >must</em> be used to make
        the correct semantic value available to the parser. In particular,
        when a grammar state defines multiple reductions, depending on the
        next token, the reduction's action only takes place following the
        retrieval of the next token, thus losing the initially matched token
        text. 
<p>
If <em >STYPE</em> is a polymorphic semantic value, specific requirements for
        assigning values to  <em >d_val__</em> apply.
        .
<p>
<li> <strong >LTYPE__ d_vsp__</strong>:<br/>
       The semantic value stack pointer. 
        Do not modify.
    </ul>
<p>
<h2 >TYPES AND VARIABLES IN THE ANONYMOUS NAMESPACE</h2>
<p>
    In the file defining the <em >parse</em> function the following types and
variables are defined in the anonymous namespace. These are mentioned here for
the sake of completeness, and are not normally accessible to other parts of
the parser.
<p>
<ul>
    <li> <strong >char const author[]</strong>:<br/>
       Defining the name and e-mail address of <strong >Bisonc++</strong>'s author.
<p>
<li> <strong >ReservedTokens</strong>:<br/>
       This enumeration defines some token values used internally by the
        parsing functions. They are:
        <pre>

    PARSE_ACCEPT   =  0,
    _UNDETERMINED_ = -2,
    _EOF_          = -1,
    _error_        = 256,
       
</pre>

       These tokens are used by the parser to determine whether another token
        should be requested from the lexical scanner, and to handle
        error-conditions. 
<p>
<li> <strong >StateType</strong>:<br/>
       This enumeration defines several moe token values used internally by
        the parsing functions. They are:
        <pre>

        NORMAL,
        ERR_ITEM,
        REQ_TOKEN,
        ERR_REQ,    // ERR_ITEM | REQ_TOKEN
        DEF_RED,    // state having default reduction
        ERR_DEF,    // ERR_ITEM | DEF_RED
        REQ_DEF,    // REQ_TOKEN | DEF_RED
        ERR_REQ_DEF // ERR_ITEM | REQ_TOKEN | DEF_RED
       
</pre>

       These tokens are used by the parser to define the types of the various
        states of the analyzed grammar.
<p>
<li> <strong >PI__</strong> (Production Info):<br/>
       This <em >struct</em> provides information about production rules. It has two
        fields: <em >d_nonTerm</em> is the identification number of the production's
        nonterminal, <em >d_size</em> represents the number of elements of the
        productin rule.
<p>
<li> <strong >static PI__ s_productionInfo</strong>:<br/>
       Used internally by the parsing function.
<p>
<li> <strong >SR__</strong> (Shift-Reduce Info):<br/>
       This <em >struct</em> provides the shift/reduce information for the various
        grammatic states. <em >SR__</em> values are collected in arrays, one array
        per grammatic state. These array, named <em >s_</em><em >&lt;nr&gt;</em>, 
        where tt&lt;nr&gt; is a state number are defined in the anonymous namespace
        as well. The <em >SR__</em> elements consist of two unions,
        defining fields that are applicable to, respectively, the first,
        intermediate and the last array elements.<br/>
       The first element of each array consists of (1st field) a <em >StateType</em>
        and (2nd field) the index of the last array element;
       intermediate elements consist of (1st field) a symbol value and (2nd
        field) (if negative) the production rule number reducing to the
        indicated symbol value or (if positive) the next state when the symbol
        given in the 1st field is the current token; 
       the last element of each array consists of (1st field) a placeholder for
        the current token and (2nd field) the (negative) rule number to reduce
        to by default or the (positive) number of an error-state to go to when
        an erroneous token has been retrieved. If the 2nd field is zero, no
        error or default action has been defined for the state, and
        error-recovery is attepted.
<p>
<li> <strong >STACK_EXPANSION__</strong>:<br/>
       An enumeration value specifying the number of additional elements that
        are added to the state- and semantic value stacks when full.
<p>
<li> <strong >static SR__ s_&lt;nr&gt;[]</strong>:<br/>
       Here, <em >&lt;nr&gt;</em> is a numerical value representing a state number.
       Used internally by the parsing function.
<p>
<li> <strong >static SR__ *s_state[]</strong>:<br/>
       Used internally by the parsing function.
    </ul>
<p>
<h2 >SEE ALSO</h2>
        <strong >bison</strong>(1), <strong >bison++</strong>(1), 
    <strong >bison++api</strong>(3), <strong >bison++input</strong>(7), 
    <strong >bison.info</strong> (using texinfo),
    <strong >flexc++</strong>(1),
    <strong >https://fbb-git.github.io/bisoncpp/</strong>
<p>
Lakos, J. (2001) <strong >Large Scale C++ Software Design</strong>, Addison Wesley.<br/>
    Aho, A.V., Sethi, R., Ullman, J.D. (1986) <strong >Compilers</strong>, Addison Wesley.
<p>
<h2 >AUTHOR</h2>
<p>
Frank B. Brokken (f.b.brokken@rug.nl).
