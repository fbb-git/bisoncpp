<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> <div style="text-align: center"><strong >Bisonc++</strong> (Version 5.00.01) User Guide</div> </title>
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
</head>
<body text="#27408B" bgcolor="#FFFAF0">
<hr>
<ul>
    <li> <a href="bisonc++.html">Table of Contents</a>
    <li> <a href="bisonc++04.html">Previous Chapter</a>
    <li> <a href="bisonc++06.html">Next Chapter</a>
</ul>
<hr>
<a name="INTERFACE"></a><a name="l76"></a>
<h1 >Chapter 5: The Generated Parser Class' Members</h1>
<strong >Bisonc++</strong> generates a <strong >C++</strong> <em >class</em>, rather than a <em >function</em> like Bison.
<strong >Bisonc++</strong>'s class is a plain <strong >C++</strong> class and not a fairly
complex macro-based class like the one generated by Bison++. The <strong >C++</strong> class
generated by <strong >bisonc++</strong> does not have (need) <em >virtual</em> members. Its
essential member (the member <code >parse</code>) is generated from the grammar
specification and so the software engineer will therefore hardly ever feel the
need to override that function. All but a few of the remaining predefined
members have very clear definitions and meanings as well, making it unlikely
that they should ever require overriding. 
<p>
It is likely that members like <code >lex</code> and/or <code >error</code> need dedicated
definitions with different parsers generated by Bison++; but then again: while
defining the grammar the definition of the associated support members is a
natural extension of defining the grammar, and can be realized <em >in parallel</em>
with defining the grammar, in practice not requiring any virtual members. By
not defining (requiring) virtual members the parser's class organization is
simplified, and calling non-virtual members will be just a trifle
faster than calling these member functions as virtual functions.
<p>
In this chapter all available members and features of the generated parser
class are discussed. Having read this chapter you should be able to use the
generated parser class in your program (using its public members) and to use
its facilities in the actions defined for the various production rules and/or
use these facilities in additional class members that you might have defined
yourself. 
<p>
In the remainder of this chapter the class's public members are first
discussed, to be followed by the class's private members. While constructing
the grammar all private members are available in the action parts of the
grammaticalrules. Furthermore, any member (and so not just from the action
blocks) may generate errors (thus initiating error recovery procedures) and
may flag the (un)successful parsing of the information given to the parser
(terminating the parsing function <code >parse</code>).
<p>
<a name="l77"></a>
<h2 >5.1: Public Members and Types</h2>
    Parser classes generated by <strong >bisonc++</strong> offer the following public members and
types (in the following overview parser class-name prefixes (e.g.,
<code >Parser::</code>) prefixes were omitted):
    <ul>
    <li> <strong >DebugMode__</strong>:<br/> 
       The values of this <code >enum</code> are used to configure the type of debug
        information that will be displayed (assuming that the <code >debug</code>
        option/directive was specified when <strong >bisonc++</strong> generated the parser's
        code). It has three values:
<p>
<code >OFF</code>: no debug information is displayed when the generated
        parser's <code >parse</code> function is called;
<p>
<code >ON</code>: extensive debug information about the parsing process is
        displayed when the generated parser's <code >parse</code> function is called;
<p>
<code >ACTIONCASES</code>: just before executing the grammar's action blocks
        the action block number is written to the standard output
        stream. These action block numbers refer to  case labels of the switch
        that is defined in the parser's <code >executeAction</code> function. It is
        commonly used to find the action block where a fatal semantic value
        mismatch was observed.
<p>
The <code >bit_or</code> operator can be used to combine <code >ON</code> and
        <code >ACTIONCASES</code> (see the member function <code >setDebug(DebugMode__
        mode)</code> below).
<p>
<li> <strong >LTYPE__</strong>:<br/> 
           The parser's location type (user-definable). Available only when
            either <code >%lsp-needed, %ltype</code> or <code >%locationstruct</code> has been
            declared. 
<p>
<li> <strong >STYPE__</strong>:<br/>
            The parser's stack-type (user-definable), defaults to <strong >int</strong>.
<p>
<li> <strong >Tokens__</strong>:<br/>
           The enumeration type of all the symbolic tokens defined in the
            grammar file (i.e., <strong >bisonc++</strong>'s input file). The scanner should be
            prepared to return these symbolic tokens. Note that, since the
            symbolic tokens are defined in the parser's class and not in the
            scanner's class, the lexical scanner must prefix the parser's
            class name to the symbolic token names when they are
            returned. E.g., <code >return Parser::IDENT</code> should be used rather
            than <code >return IDENT</code>.
<p>
<li> <strong >int parse()</strong>:<br/>
           The parser's parsing member function. It returns 0 when parsing was
            successfully completed; 1 if errors were encountered while parsing
            the input.
<p>
<li> <strong >void setDebug(bool mode)</strong>:<br/>
       This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is always defined but is only
        operational if the <code >debug</code> directive option was specified when <strong >bisonc++</strong>
        generated the <code >parse</code> function. If so, it is <em >not</em> active by
        default; to activate the debug output call <code >setDebug(true)</code>, to
        suppress the debug output call <code >setDebug(false)</code>.
<p>
<li> <strong >void setDebug(DebugMode__ mode)</strong>:<br/>
       This member can also be used to activate or deactivate the debug-code
        compiled into the parsing function. Like <code >setDebug(bool)</code> it is
        always defined but only operational if the <code >debug</code> directive option
        was specified when <strong >bisonc++</strong> generated the <code >parse</code> function. If so, it
        is <em >not</em> active by default; to activate, call
        <code >setDebug(Parser::ON), setDebug(Parser::ACTIONCASES)</code>, or 
        <code >setDebug(Parser::ON | Parser::ACTIONCASES)</code>. To suppress the
        debug code output call <code >setDebug(Parser__::OFF)</code> or simply
        <code >setDebug(false)</code>.
    </ul>
<p>
When the <code >%polymorphic</code> directive is used:
    <ul>
    <li> <strong >Meta__</strong>:<br/>
           Templates and classes that are required for implementing the
            polymorphic semantic values are all declared in the <code >Meta__</code>
            namespace. The <code >Meta__</code> namespace itself is nested under the
            namespace that may have been declared by the <code >%namespace</code>
            directive.
<p>
<li> <strong >Tag__</strong>:<br/>
           The (strongly typed) <code >enum class Tag__</code> contains all the
            tag-identifiers specified by the <code >%polymorphic</code> directive. It is
            declared outside of the Parser's class, but within the namespace
            that may have been declared by the <code >%namespace</code> directive.
    </ul>
<p>
<a name="l78"></a>
<h2 >5.2: Protected Enumerations and Types</h2>
    The following enumerations and types can be used by members of parser
classes generated by <strong >bisonc++</strong>. They are actually protected members inherited from
the parser's base class.
    <ul>
    <li> <strong >Base::ErrorRecovery__</strong>:<br/>
        This enumeration defines two values:
        <pre>

    DEFAULT_RECOVERY_MODE__,
    UNEXPECTED_TOKEN__
        
</pre>

       The <code >DEFAULT_RECOVERY_MODE__</code> terminates the parsing process. The
        non-default recovery procedure is available once an <code >error</code> token is
        used in a production rule. When the parsing process throws
        <code >UNEXPECTED_TOKEN__</code> the recovery procedure is started (i.e., it is
        started whenever a syntactic error is encountered or 
        <code >ERROR</code><code >()</code> is called). 
<p>
The recovery procedure consists of (1) looking for the first state on
        the state-stack having an error-production, followed by (2) handling
        all state transitions that are possible without retrieving a terminal
        token. Then, in the state requiring a terminal token and starting with
        the initial unexpected token (3) all subsequent terminal tokens are
        ignored until a token is retrieved which is a continuation token in
        that state. 
<p>
If the error recovery procedure fails (i.e., if no acceptable token is
        ever encountered) error recovery falls back to the default recovery
        mode (i.e., the parsing process is terminated).
<p>
<li> <strong >Base::Return__</strong>:<br/>
        This enumeration defines two values:
        <pre>

    PARSE_ACCEPT = 0,
    PARSE_ABORT = 1
        
</pre>

        (which are of course the <code >parse</code> function's return values).
     </ul>
<p>
When the <code >%polymorphic</code> directive is used:
    <ul>
    <li> <strong >Meta__::sizeofTag</strong>:<br/>
           <code >sizeofTag</code> defines the number of tags that were defined for 
            polymorphic semantic values.
    </ul>
<p>
<a name="PRIVMEM"></a><a name="l79"></a>
<h2 >5.3: Non-public Member Functions</h2>
    The following members can be used by members of parser classes generated
by <strong >bisonc++</strong>. When prefixed by <code >Base::</code> they are actually protected members
inherited from the parser's base class.  Members for which the phrase ``Used
internally'' is used should not be called by user-defined code.
    <ul>
    <li> <strong >Base::ParserBase()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::ABORT() const throw(Return__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to indicate a failure while parsing thus
        terminating the parsing function with an error value 1. Note that this
        offers a marked extension and improvement of the macro <code >YYABORT</code>
        defined by <strong >bison++</strong> in that <code >YYABORT</code> could not be called from
        outside of the parsing member function.
<p>
<li> <strong >void Base::ACCEPT() const throw(Return__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to indicate successful parsing and thus
        terminating the parsing function. Note that this offers a marked
        extension and improvement of the macro <code >YYACCEPT</code> defined by
        <strong >bison++</strong> in that <code >YYACCEPT</code> could not be called from outside of
        the parsing member function.
<p>
<li> <strong >void Base::clearin()</strong>:<br/>
       This member replaces <strong >bison</strong>(++)'s macro <code >yyclearin</code> and causes
        <strong >bisonc++</strong> to request another token from its <code >lex+nop()()</code> member,
        even if the current token has not yet been processed. It is a useful
        member when the parser should be reset to its initial state, e.g.,
        between successive calls of <code >parse</code>. In this situation the scanner
        must probably be reloaded with new information as well.
<p>
<li> <strong >bool Base::debug() const</strong>:<br/>
       This member returns the current value of the debug variable.
<p>
<li> <strong >void Base::ERROR() const throw(ErrorRecovery__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to generate an error, and results in the
        parser executing its error recovery code. Note that this offers a
        marked extension and improvement of the macro <code >YYERROR</code> defined by
        <strong >bison++</strong> in that <code >YYERROR</code> could not be called from outside of
        the parsing member function.
<p>
<li> <strong >void error(char const *msg)</strong>:<br/>
      By default implemented inline in the <code >parser.ih</code> internal header file,
       it writes a simple message to the standard error stream. It is called
       when a syntactic error is encountered, and its default implementation
       may safely be altered.
<p>
<li> <strong >void errorRecovery__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::errorVerbose__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void exceptionHandler__(std::exception const &amp;exc)</strong>:<br/>
       This member's default implementation is provided inline in the
        <code >parser.ih</code> internal header file. It consists of a mere <code >throw</code>
        statement, rethrowing a caught exception.
<p>
The <code >parse</code> member function's body essentially consists of a
        <code >while</code> statement, in which the next token is obtained via the
        parser's <code >lex</code> member. This token is then processed according to the
        current state of the parsing process. This may result in executing
        actions over which the parsing process has no control and which may
        result in exceptions being thrown.
<p>
Such exceptions do not necessarily have to terminate the parsing
        process: they could be thrown by code, linked to the parser, that
        simply checks for semantic errors (like divisions by zero) 
        throwing exceptions if such errors are observed.
<p>
The member <code >exceptionHandler__</code> receives and may handle such
        exceptions without necessarily ending the parsing process. It receives
        any <code >std::exception</code> thrown by the parser's actions, as though the
        action block itself was surrounded by a <code >try ... catch</code> statement.
        It is of course still possible to use an explicit <code >try ... catch</code>
        statement within action blocks. However, <code >exceptionHandler__</code> can
        be used to factor out code that is common to various action blocks.
<p>
The next example shows an explicit implementation of
        <code >exceptionHandler__</code>: any <code >std::exception</code> thrown by the parser's
        action blocks is caught, showing the exception's message, and
        increasing the parser's error count. After this parsing continues as
        if no exception had been thrown:
        <pre>

void Parser::exceptionHandler__(std::exception const &amp;exc)
{
    std::cout &lt;&lt; exc.what() &lt;&lt; '\n';
    ++d_nErrors__;
}
        
</pre>

<p>
<strong >Note:</strong> Parser-class header files (e.g., Parser.h) and parser-class
    internal header files (e.g., Parser.ih) generated with <strong >bisonc++</strong> &lt; 4.02.00
    require two small hand-modifications when using <strong >bisonc++</strong> &gt;= 4.02.00:
<p>
In Parser.h, just below the declaration 
        <pre>

void print__();
    
</pre>

    add:
    <pre>

void exceptionHandler__(std::exception const &amp;exc);
    
</pre>

<p>
In Parser.ih, assuming the name of the generated class is `Parser', add the
    following member definition (if a namespace is used: within the
    namespace's scope):
        <pre>

inline void Parser::exceptionHandler__(std::exception const &amp;exc)
{
    throw;  // re-implement to handle exceptions thrown by actions
}
    
</pre>

<p>
<li> <strong >void executeAction(int)</strong>:<br/>
       Used internally.
<p>
<li> <strong >int lex()</strong>:<br/>
      By default implemented inline in the <code >parser.ih</code> internal header file,
       it can be pre-implemented by <strong >bisonc++</strong> using the <code >scanner</code> option or
       directive (see above); alternatively it <em >must</em> be implemented by the
       programmer. It interfaces to the lexical scanner, and should return the
       next token produced by the lexical scanner, either as a plain character
       or as one of the symbolic tokens defined in the <code >Parser::Tokens__</code>
       enumeration. Zero or negative token values are interpreted as `end of
       input'.
<p>
<li> <strong >int lookup(bool)</strong>:<br/>
       Used internally.
<p>
<li> <strong >void nextToken()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::pop__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::popToken__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void print__()()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void print()</strong>:<br/>
      By default implemented inline in the <code >parser.ih</code> internal header file,
       this member calls <code >print__</code> to display the last received token and
       corrseponding matched text. The <code >print__</code> member is only implemented
       if the <code >--print-tokens</code> option or <code >%print-tokens</code> directive was
       used when the parsing function was generated. Calling <code >print__</code> from
       <code >print</code> is unconditional, but can easily be controlled by the using
       program, by defining, e.g., a command-line option.
<p>
<li> <strong >void Base::push__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::pushToken__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::reduce__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::symbol__()</strong>:<br/>
       Used internally.
<p>
<li> <strong >void Base::top__()</strong>:<br/>
       Used internally.
    </ul>
<p>
<a name="LEX"></a><a name="l80"></a>
<h3 >5.3.1: `lex()': Interfacing the Lexical Analyzer</h3>
        The <code >int lex()</code> private member function is called by the <code >parse()</code>
member to obtain the next lexical token. By default it is not implemented, but
the <code >%scanner</code> directive (see section <a href="bisonc++04.html#SCANNER">4.5.20</a>) may be used to
pre-implement a standard interface to a lexical analyzer.
<p>
The <code >lex()</code> member function interfaces to the lexical scanner, and it is
expected to return the next token produced by the lexical scanner. This token
may either be a plain character or it may be one of the symbolic tokens
defined in the <strong >Parser::Tokens</strong> enumeration. Any zero or negative token
value is interpreted as `end of input', causing <code >parse()</code> to return.
<p>
The <code >lex()</code> member function may be implemented in various ways:
    <ul>
    <li> By default, if the <code >--scanner</code> option or <code >%scanner</code> directive is
provided <strong >bisonc++</strong> assumes that it should interface to the scanner generated by
<strong >flexc++</strong>(1). In this case, the scanner token function is called as
        <pre>

    d_scanner.lex()
        
</pre>

    and the scanner's matched text function is called as 
        <pre>

    d_scanner.matched()
        
</pre>

<p>
<li> <code >lex()</code> may itself implement a lexical analyzer (a
<em >scanner</em>). This may actually be a useful option when the input offered to
the program using <strong >bisonc++</strong>'s parser class is not overly complex. This approach was
used when implementing the earlier examples (see sections <a href="bisonc++06.html#RPNLEX">6.1.3</a> and 
<a href="bisonc++06.html#MFLEX">6.4.4</a>).
<p>
<li> <code >lex()</code> may call a external function or member function of class
implementing a lexical scanner, and return the information offered by this
external function. When using a class, an object of that class could also be
defined as additional data member of the parser (see the next
alternative). This approach can be followed when generating a lexical scanner
from a lexical scanner generating tool like <strong >lex</strong>(1) or <strong >flex++</strong>(1). The
latter program allows its users to generate a scanner <em >class</em>.
<p>
<li> To interface <strong >bisonc++</strong> to code generated by <strong >flex</strong>(1), the <code >--flex</code>
option or <code >%flex</code> directive can be used in combination with the
<code >--scanner</code> directive or <code >%scanner</code> option. In this case the scanner token
function is called as 
        <pre>

    d_scanner.yylex()
        
</pre>

    and the scanner's matched text function is called as 
        <pre>

    d_scanner.YYText()
        
</pre>

    </ul>
<p>
<a name="PRIVDATA"></a><a name="l81"></a>
<h2 >5.4: Protected Data Members</h2>
    The following private members can be used by members of parser classes
generated by <strong >bisonc++</strong>. All data members are actually protected
members inherited from the parser's base class. 
    <ul>
    <li> <strong >size_t d_acceptedTokens__</strong>:<br/>
       Counts the number of accepted tokens since the start of the <code >parse()</code>
        function or since the last detected syntactic error. It is initialized
        to <code >d_requiredTokens__</code> to allow an early error to be detected as
        well. 
<p>
<li> <strong >bool d_actionCases__</strong>:<br/>
       When the <strong >debug</strong> option has been specified, this variable (<strong >false</strong>
        by default) determines whether the numbers of the case-entries that
        are about to be executed by the parser's <code >executeAction</code> member are
        displayed to the standard output stream.
<p>
<li> <strong >bool d_debug__</strong>:<br/>
       When the <strong >debug</strong> option has been specified, this variable (<strong >true</strong>
        by default) determines whether debug information is actually
        displayed.
<p>
<li> <strong >LTYPE__ d_loc__</strong>:<br/>
       The location type value associated with a terminal token. It can be
        used by, e.g., lexical scanners to pass location information of a
        matched token to the parser in parallel with a returned token. It is
        available only when <strong >%lsp-needed, %ltype</strong> or <strong >%locationstruct</strong> has
        been defined. <br/>
       Lexical scanners may be offered the facility to assign a value to this
        variable in parallel with a returned token. In order to allow a
        scanner access to <strong >d_loc__</strong>, <strong >d_loc__</strong>'s address should be passed
        to the scanner. This can be realized, for example, by defining a
        member <strong >void setLoc(LTYPE__ *loc)</strong> in the lexical scanner, which is
        then called from the parser's constructor as follows:
       <pre>

            d_scanner.setSLoc(&amp;d_loc__);
       
</pre>

       Subsequently, the lexical scanner may assign a value to the parser's
        <strong >d_loc__</strong> variable through the pointer to <strong >d_loc__</strong> stored inside
        the lexical scanner.
<p>
<li> <strong >LTYPE__ d_lsp__</strong>:<br/>
       The location stack pointer. Used internally.
<p>
<li> <strong >size_t d_nErrors__</strong>:<br/>
       The number of errors counted by <code >parse()</code>. It is initialized by the
        parser's base class initializer, and is updated while <code >parse()</code>
        executes. When <code >parse()</code> has returned it contains the total number
        of errors counted by <code >parse()</code>. Errors are not counted if suppressed
        (i.e., if <code >d_acceptedTokens__</code> is less than <code >d_requiredTokens__</code>).
<p>
<li> <strong >size_t d_nextToken__</strong>:<br/>
       A pending token. 
        Do not modify.
<p>
<li> <strong >size_t d_requiredTokens__</strong>:<br/>
       Defines the minimum number of accepted tokens that the <code >parse()</code>
        function must have processed before a syntactic error can be
        generated. 
<p>
<li> <strong >int d_state__</strong>:<br/>
       The current parsing state. 
        Do not modify.
<p>
<li> <strong >int d_token__</strong>:<br/>
       The current token. 
        Do not modify.
<p>
<li> <a name="DVAL"></a> <strong >STYPE__ d_val__</strong>:<br/>
       The semantic value of a returned token or nonterminal symbol. With
        nonterminal tokens it is assigned a value through the action rule's
        symbol <strong >$$</strong>. Lexical scanners may be offered the facility to assign
        a semantic value to this variable in parallel with a returned
        token. In order to allow a scanner access to <strong >d_val__</strong>,
        <strong >d_val__</strong>'s address should be passed to the scanner. This can be
        realized, for example, by defining a member <strong >void setSval(STYPE__
        *)</strong> in the lexical scanner, which is then called from the parser's
        constructor as follows:
       <pre>

            d_scanner.setSval(&amp;d_val__);
       
</pre>

       Subsequently, the lexical scanner may assign a value to the parser's
        <strong >d_val__</strong> variable through the pointer to <strong >d_val__</strong> stored inside
        the lexical scanner.
<p>
Note that in some cases this approach <em >must</em> be used to make
        available the correct semantic value to the parser. In particular,
        when a grammar state defines multiple reductions, depending on the
        next token, the reduction's action only takes place following the
        retrieval of the next token, thus losing the initially matched token
        text. As an example, consider the following little grammar:
            <pre>

        expr:
            name
        |
            ident '(' ')'
        |
            NR
        ;

        name:   
            IDENT
        ;

        ident: IDENT ; 
            
</pre>
 
       Having recognized <code >IDENT</code> two reductions are possible: to <code >name</code>
        and to <code >ident</code>. The reduction to <code >ident</code> is appropriate when the
        next token is <code >(</code>, otherwise the reduction to <code >name</code> is
        performed. So, the parser asks for the next token, thereby
        destroying the text matching <code >IDENT</code> before <code >ident</code> or <code >name</code>'s
        actions are able to save the text themselves. To enure the
        availability of the text matching <code >IDENT</code> is situations like these
        the <em >scanner</em> must assign the proper semantic value when it
        recognizes a token. Consequently the parser's <code >d_val__</code> data member
        must be made available to the scanner.
<p>
If <code >STYPE__</code> is a polymorphic semantic value, direct assignment of
        values to <code >d_val__</code> is not possible. In that case <em >tagged
        assignment</em> must be 
        used.
<p>
<li> <strong >LTYPE__ d_vsp__</strong>:<br/>
       The semantic value stack pointer. 
        Do not modify.
    </ul>
<p>
<a name="l82"></a>
<h2 >5.5: Types and Variables in the Anonymous Namespace</h2>
    In the file defining the <code >parse</code> function the following types and
variables are defined in the anonymous namespace. These are mentioned here for
the sake of completeness, and are not normally accessible to other parts of
the parser.
<p>
<ul>
    <li> <strong >char const author[]</strong>:<br/>
       Defining the name and e-mail address of <strong >Bisonc++</strong>'s author.
<p>
<li> <strong >ReservedTokens</strong>:<br/>
       This enumeration defines some token values used internally by the
        parsing functions. They are:
        <pre>

    PARSE_ACCEPT   =  0,
    _UNDETERMINED_ = -2,
    _EOF_          = -1,
    _error_        = 256,
       
</pre>

       These tokens are used by the parser to determine whether another token
        should be requested from the lexical scanner, and to handle
        error-conditions. 
<p>
<li> <strong >StateType</strong>:<br/>
       This enumeration defines several moe token values used internally by
        the parsing functions. They are:
        <pre>

        NORMAL,
        ERR_ITEM,
        REQ_TOKEN,
        ERR_REQ,    // ERR_ITEM | REQ_TOKEN
        DEF_RED,    // state having default reduction
        ERR_DEF,    // ERR_ITEM | DEF_RED
        REQ_DEF,    // REQ_TOKEN | DEF_RED
        ERR_REQ_DEF // ERR_ITEM | REQ_TOKEN | DEF_RED
       
</pre>

       These tokens are used by the parser to define the types of the various
        states of the analyzed grammar.
<p>
<li> <strong >PI__</strong> (Production Info):<br/>
       This <code >struct</code> provides information about production rules. It has two
        fields: <code >d_nonTerm</code> is the identification number of the production's
        nonterminal, <code >d_size</code> represents the number of elements of the
        productin rule.
<p>
<li> <strong >static PI__ s_productionInfo</strong>:<br/>
       Used internally by the parsing function.
<p>
<li> <strong >SR__</strong> (Shift-Reduce Info):<br/>
       This <code >struct</code> provides the shift/reduce information for the various
        grammatic states. <code >SR__</code> values are collected in arrays, one array
        per grammatic state. These array, named <code >s_</code><code >&lt;nr&gt;</code>, 
        where tt&lt;nr&gt; is a state number are defined in the anonymous namespace
        as well. The <code >SR__</code> elements consist of two unions,
        defining fields that are applicable to, respectively, the first,
        intermediate and the last array elements.<br/>
       The first element of each array consists of (1st field) a <code >StateType</code>
        and (2nd field) the index of the last array element;
       intermediate elements consist of (1st field) a symbol value and (2nd
        field) (if negative) the production rule number reducing to the
        indicated symbol value or (if positive) the next state when the symbol
        given in the 1st field is the current token; 
       the last element of each array consists of (1st field) a placeholder for
        the current token and (2nd field) the (negative) rule number to reduce
        to by default or the (positive) number of an error-state to go to when
        an erroneous token has been retrieved. If the 2nd field is zero, no
        error or default action has been defined for the state, and
        error-recovery is attepted.
<p>
<li> <strong >STACK_EXPANSION</strong>:<br/>
       An enumeration value specifying the number of additional elements that
        are added to the state- and semantic value stacks when full.
<p>
<li> <strong >static SR__ s_&lt;nr&gt;[]</strong>:<br/>
       Here, <code >&lt;nr&gt;</code> is a numerical value representing a state number.
       Used internally by the parsing function.
<p>
<li> <strong >static SR__ *s_state[]</strong>:<br/>
       Used internally by the parsing function.
    </ul>
<p>
<a name="SPECIAL"></a><a name="l83"></a>
<h2 >5.6: Summary of Special Constructions for Actions</h2>
Here is an overview of special syntactic constructions that may be used
inside action blocks:
    <ul>
    <li><code >$$</code> and <code >$i</code> notations represent semantic values of the nonterminal
defined by production rules and semantic values of components of production
rules. Different `dollar-notations' are available for different types (single,
union, or polymorphic) of semantic values. Refer to section <a href="bisonc++04.html#ACTIONS">4.6.2</a> for a
complete description.
<p>
<li><code >@@</code> and <code >@n</code>: Usually these represent plain old data (a <strong >C</strong>-type
structure) containing information about line numbers and column numbers that
is associated with, respectively, the rule's nonterminal and the production
rule's n<sup >th</sup> component. The default structure is defined like this (see
also section <a href="bisonc++04.html#LSPNEEDED">4.5.11</a>):
           <pre>

    struct LTYPE__
    {
        int timestamp;
        int first_line;
        int first_column;
        int last_line;
        int last_column;
        char *text;
    };
           
</pre>

    Thus, to get the starting line number of the third component, you would
use <code >@3.first_line</code>.
<p>
In order for the members of this structure to contain valid information,
you must make sure the lexical scanner supplies this information about each
token. If you need only certain fields, then the lexical scanner 
only has to provide those fields. 
<p>
Be advised that using this or corresponding (custom-defined, see sections
<a href="bisonc++04.html#LTYPE">4.5.12</a> and <a href="bisonc++04.html#LOCSTRUCT">4.5.10</a>) may slow down the parsing process noticeably.
    </ul>
<p>
<hr>
<ul>
    <li> <a href="bisonc++.html">Table of Contents</a>
    <li> <a href="bisonc++04.html">Previous Chapter</a>
    <li> <a href="bisonc++06.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
