<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>bisonc++</title>
<style type="text/css">
    body {color: #27408B; background: #FFFAF0;}
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body>
<hr/>
<h1 id="title">bisonc++</h1>
<h2 id="author">bisonc++.5.00.01.tar.gz</h2>
<h2 id="date">2005-2016</h2>

<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<style type="text/css">
    body {color: #27408B; background: #FFFAF0;}
    figure {text-align: center;}
    img {vertical-align: center;}
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body>
<hr/>
<h1 id="title"></h1>

<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>bisonc++(1)</title>
<style type="text/css">
    body {color: #27408B; background: #FFFAF0;}
    figure {text-align: center;}
    img {vertical-align: center;}
    figure {text-align: center;}
    img {vertical-align: center;}
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body>
<hr/>
<h1 id="title">bisonc++(1)</h1>
<h2 id="author">bisonc++.5.00.01.tar.gz bisonc++ parser generator</h2>
<h2 id="date">2005-2016</h2>


<p>

<h2 >NAME</h2>bisonc++ - Generate a C++ parser class and parsing function
<p>

<h2 >SYNOPSIS</h2>
       <strong >bisonc++</strong> [OPTIONS] <em >grammar-file</em>
<p>
<h2 >DESCRIPTION</h2>
<p>
<strong >Bisonc++</strong> derives from previous work on <strong >bison</strong> by Alain Coetmeur
(coetmeur@icdc.fr), who created in the early '90s a <strong >C++</strong> class encapsulating
the <em >yyparse</em> function as generated by the GNU-<strong >bison</strong> parser generator.
<p>
Initial versions of <strong >bisonc++</strong> (up to version 0.92) wrapped Alain's program in
a program offering a more modern user-interface, removing all old-style
(<strong >C</strong>) <em >%define</em> directives from <strong >bison++</strong>'s input specification file
(see below for an in-depth discussion of the differences between <strong >bison++</strong>
and <strong >bisonc++</strong>). Starting with version 0.98, <strong >bisonc++</strong> represents a complete rebuilt of
the parser generator, closely following descriptions given in Aho, Sethi and
Ullman's <em >Dragon Book</em>. Since version 0.98 <strong >bisonc++</strong> is a <strong >C++</strong> program, rather
than a <strong >C</strong> program generating <strong >C++</strong> code.
<p>
<strong >Bisonc++</strong> expands the concepts initially implemented in <strong >bison</strong> and
<strong >bison++</strong>, offering a cleaner setup of the generated parser class. The
parser class is derived from a base-class, mainly containing the parser's
token- and type-definitions as well as several member functions which should
not be modified by the programmer. 
<p>
Most of these base-class members might also be defined directly in the
parser class, but were defined in the parser's base-class. This design results
in a very lean parser class, declaring only members that are actually defined
by the programmer or that have to be defined by <strong >bisonc++</strong> itself (e.g., the
member function <em >parse</em> as well as some support functions requiring access
to facilities that are only available in the parser class itself, rather than
in the parser's base class).  
<p>
This design does not require any virtual members: the members which are
not involved in the actual parsing process may always be (re)implemented
directly by the programmer. Thus there is no need to apply or define virtual
member functions.
<p>
Before version 5.00.00 <strong >bisonc++</strong> offered one single manual page. The advantage
of one man-page is of course that you never have to look for which manual page
contains which information. But on the other hand, <strong >bisonc++</strong>'s man-page grew into
a huge man-page of about 2000 lines in which it was hard to find your
way. From release 5.00.00 onward, three man-pages. The following index relates
manual pages to their specific contents:
<p>
<strong >This man-page</strong>
<p>
This man-page concentrates on the <em >bisonc++</em> program itself, offering
the following sections:
<p>
<ul>
    <li> <strong >DESCRIPTION</strong>: a short description of <strong >bisonc++</strong> and its roots;
    <li> <strong >OPTIONS</strong>: options supported by <strong >bisonc++</strong>.
    <li> <strong >QUICK START</strong>: a quick start overview about how to use <strong >bisonc++</strong>;
    <li> <strong >GENERATED FILES</strong>: files generated by <strong >bisonc++</strong> and their purposes
    <li> <strong >FILES</strong>: skeleton</ul> files used by <strong >bisonc++</strong>;
    <li> <strong >SEE ALSO</strong>: references to other programs and documentation;
    <li> <strong >BUGS</strong>: some additional stuff that should not qualify as bugs.
    <li> <strong >ABOUT bisonc++</strong>: Some history;
    <li> <strong >AUTHOR</strong>: at the end of this man-page.
    )
<p>
The <strong >bisonc++input</strong>(7) man-page covers the details of the
grammar-specification file. This man-page offers these sections:
    <ul>
    <li> <strong >DESCRIPTION</strong>: a short description of <strong >bisonc++</strong> and its grammar
            <strong >s</strong>;
    <li> <strong >DIRECTIVES</strong>: <strong >bisonc++</strong>'s grammar-specification directives;
    <li> <strong >POLYMORPHIC SEMANTIC VALUES</strong>: how to use polymorphic semantic
            values in parsers generated by <strong >bisonc++</strong>;
    <li> <strong >DOLLAR NOTATIONS</strong>: available $-shorthand notations with single,
        union, and polymorphic semantic value types.
    <li> <strong >RESTRICTIONS ON TOKEN NAMES</strong>: name restrictions for user-defined
            symbols;
    <li> <strong >OBSOLETE SYMBOLS</strong>: symbols available to <strong >bison</strong>(1), but not
            to <strong >bisonc++</strong>;
    <li> <strong >EXAMPLE</strong>: an example of using <strong >bisonc++</strong>;
    <li> <strong >USING PARSER-CLASS SYMBOLS IN LEXICAL SCANNERS</strong>: how to refer
            to tokens defined in the grammar from within a lexical scanner;
    <li> <strong >SEE ALSO</strong>: references to other programs and documentation;
    <li> <strong >AUTHOR</strong>: at the end of this man-page.
    </ul>
<p>
The <strong >bisonc++api</strong>(3) describes the application programmer's
            interface, containing these sections:
    <ul>
    <li> <strong >DESCRIPTION</strong>: a short description of <strong >bisonc++</strong> and its application
            programmer's interface;
    <li> <strong >PUBLIC MEMBERS AND -TYPES</strong>: members and types that can be used
           by calling software;
    <li> <strong >PRIVATE ENUMS AND -TYPES</strong>: enumerations and types only
           available to the <em >Parser</em> class;
    <li> <strong >PRIVATE MEMBER FUNCTIONS</strong>: member functions that are only
           available to the <em >Parser</em> class;
    <li> <strong >PRIVATE DATA MEMBERS</strong>: data members that are only available to
           the <em >Parser</em> class;
    <li> <strong >TYPES AND VARIABLES IN THE ANONYMOUS NAMESPACE</strong>: an overview of
           the types and variables that are used to define and store the
           grammar-tables generated by <strong >bisonc++</strong>;
    <li> <strong >SEE ALSO</strong>: references to other programs and documentation;
    <li> <strong >AUTHOR</strong>: at the end of this man-page.
    </ul>
<p>
<h2 >OPTIONS</h2>
        Where available, single letter options are listed between parentheses
beyond their associated long-option variants. Single letter options require
arguments if their associated long options also require arguments. Options
affecting the class- or implementation header files are ignored if these
files already exist. Options accepting a `filename' do not accept path names,
i.e., they cannot contain directory separators (<em >/</em>); options accepting a
'pathname' may contain directory separators.
<p>
Some options may produce errors. This happens when they conflict with the
contents of a file which <strong >bisonc++</strong> cannot modify (e.g., a parser class header file
exists, but doesn't define a namespace, but a <em >--namespace</em> option was
provided).
<p>
To solve the error the offending option could be omitted, the existing file
could be removed, or the existing file could be hand-edited according to the
option's specification. Note that <strong >bisonc++</strong> currently does not handle the opposite
error condition: if a previously used option is omitted, then <strong >bisonc++</strong> does not
detect the inconsistency. In those cases compilation errors may be
encountered.
<p>
<ul>
    <li> <strong >--action-cases</strong> (<strong >-a</strong>)<br/>
           This option is only interpreted when polymorphic semantic values
            are used (see section
??
<p>
for details about this directive). When the generated parser
            attempts to retrieve an incorrect polymorphic value a fatal error
            is generated, ending <strong >bisonc++</strong>'s run. The error message itself cannot
            refer to the action block where the error occurred. If this
            situation is encountered, <strong >bisonc++</strong> can be rerun with this option to
            find the executeAction switch's case entry where the fatal error
            is encountered.
<p>
<li> <strong >--analyze-only</strong> (<strong >-A</strong>)<br/>
           Only analyze the grammar. No files are (re)written. This option can
            be used to test the grammatic correctness of modification `in
            situ', without overwriting previously generated files. If the
            grammar contains syntactic errors only syntax analysis is 
            performed.
<p>
<li> <strong >--baseclass-header</strong>=<em >filename</em> (<strong >-b</strong>)<br/>
           <em >Filename</em> defines the name of the file to contain the parser's
            base class. This class defines, e.g., the parser's symbolic
            tokens. Defaults to the name of the parser class plus the suffix
            <em >base.h</em>. It is generated, unless otherwise indicated (see
            <em >--no-baseclass-header</em> and <em >--dont-rewrite-baseclass-header</em>
            below).
<p>
It is an error if this option is used and an already
            existing parser class header file does not contain <em >#include
            "filename"</em>.
<p>
<li> <a name="PREINCLUDE"></a> <strong >--baseclass-preinclude</strong>=<em >pathname</em> (<strong >-H</strong>)<br/>
           <em >Pathname</em> defines  the path to the file preincluded in the
            parser's base-class header. This option is needed in situations
            where the base class header file refers to types which might not
            yet be known. E.g., with polymorphic semantic values a
            <em >std::string</em> value type might be used. Since the <em >string</em>
            header file is not by default included in <em >parserbase.h</em> we
            somehow need to inform the compiler about this and possibly other
            headers. The suggested procedure is to use a pre-include header
            file declaring the required types. By default `<em >header</em>' is
            surrounded by double quotes: <em >#include "header"</em> is used when
            the option <em >-H header</em> is specified.  When the argument is
            surrounded by pointed brackets <em >#include &lt;header&gt;</em> is
            included. In the latter case, quotes might be required to escape
            interpretation by the shell (e.g., using <em >-H '&lt;header&gt;'</em>).
<p>
<li> <strong >--baseclass-skeleton</strong>=<em >pathname</em> (<strong >-B</strong>)<br/> 
           <em >Pathname</em> defines the path name to the file containing the
            skeleton of the parser's base class. It defaults to the
            installation-defined default path name (e.g.,
            <em >/usr/share/bisonc++/</em> plus <em >bisonc++base.h</em>).
<p>
<li> <strong >--class-header</strong>=<em >filename</em> (<strong >-c</strong>)<br/>
           <em >Filename</em> defines the name of the file to contain the parser
            class. Defaults to the name of the parser class plus the suffix
            <em >.h</em>
<p>
It is an error if this option is used and an already
            existing implementation header file does not contain <em >#include
            "filename"</em>.
<p>
<li> <strong >--class-name</strong> <em >className</em> <br/>
           Defines the name of the <strong >C++</strong> class that is generated.  If
            neither this option, nor the <em >%class-name</em> directory is
            specified, then the default class name (<em >Parser</em>) is used.
<p>
It is an error if this option is used and <em >className</em> differs
            from the name of the class that is defined in an already existing
            parser-class header file and/or if an already existing
            implementation header file does not define members of the class
            <em >`className'</em>.
<p>
<li> <strong >--class-skeleton</strong>=<em >pathname</em> (<strong >-C</strong>)<br/>
           <em >Pathname</em> defines the path name to the file containing the
            skeleton of the parser class. It defaults to the
            installation-defined default path name (e.g.,
            <em >/usr/share/bisonc++/</em> plus <em >bisonc++.h</em>).
<p>
<li> <strong >--construction</strong><br/> 
           Details about the construction of the parsing tables are written to
            the same file as written by the <em >--verbose</em> option (i.e.,
            <em >&lt;grammar&gt;.output</em>, where <em >&lt;grammar&gt;</em> is the input file read
            by <strong >bisonc++</strong>). This information is primarily useful for developers. It
            augments the information written to the verbose grammar output
            file, generated by the <em >--verbose</em> option.
<p>
<li> <strong >--debug</strong><br/> 
           Provide the generated <em >parse</em> and its support functions with
            debugging code, optionally showing the actual parsing process on
            the standard output stream. When included, the debugging output is
            active by default, but its activity may be controlled using the
            <em >setDebug(bool on-off)</em> member. <strong >Bisonc++</strong> does not use <em >#ifdef
            DEBUG</em> macros. Rerun <strong >bisonc++</strong> without the <em >--debug</em> option to
            remove the debugging code.
<p>
Note that this option does <em >not</em> show the actions of <strong >bisonc++</strong>'s own
            parser, its own lexical scanner or merely the numbers of the
            case-entries executed by the parser's <em >parse</em> function. If that
            is what you want, use the <em >--own-debug, --action-cases,
            --scanner-debug</em> and/or <em >--own-tokens</em> options.
<p>
<li> <strong >--default-actions</strong>=<em >off|quiet|warn</em> (<strong >-d</strong>)<br/>
           When <em >warn</em> is specified (which is the default) an action block
            executing <em >$$ = $1</em> (or <em >$$ = STYPE__{}</em> for empty production
            rules) is added to production rules that do not explicitly define
            their own final action blocks, while issuing a warning. When
            <em >quiet</em> is specified these action blocks are silently added. It
            is an error when the types of $$ and $1 differ (but it is OK if
            neither $$ nor $1 is associated with a specific type). When
            <em >off</em> is specified no action blocks are added (issuing a warning
            issued, unless the option/directive <em >tag-mismatches off</em> has
            been specified).
<p>
<li> <a name="ERRORVERBOSE"></a><strong >--error-verbose</strong><br/>
           When a syntactic error is reported, the generated parse function
            dumps the parser's state stack to the standard output
            stream. The stack dump shows on separate lines a stack index
            followed by the state stored at the indicated stack element. The
            first stack element is the stack's top element.
<p>
<li> <strong >--filenames</strong>=<em >filename</em> (<strong >-f</strong>)<br/>
           <em >Filename</em> is a generic file name that is used for all header
            files generated by <strong >bisonc++</strong>. Options defining specific file names are
            also available (which then, in turn, overrule the name specified
            by this option).
<p>
<li> <strong >--flex</strong><br/> 
           <strong >Bisonc++</strong> generates code calling <em >d_scanner.yylex()</em> to obtain the
            next lexical token, and calling <em >d_scanner.YYText()</em> for the
            matched text, unless overruled by options or directives explicitly
            defining these functions. By default, the interface defined by
            <strong >flexc++</strong>(1) is used. This option is only interpreted if the
            <em >--scanner</em> option or <em >%scanner</em> directive is also used.
<p>
<li> <strong >--help</strong> (<strong >-h</strong>)<br/>
            Write basic usage information to the standard output stream and
            terminate. 
<p>
<li> <strong >--implementation-header</strong>=<em >filename</em> (<strong >-i</strong>)<br/>
           <em >Filename</em> defines the name of the file to contain the
            implementation header. It defaults to the name of the generated
            parser class plus the suffix <em >.ih</em>.
<p>
The implementation header should contain all directives and
            declarations <em >only</em> used by the implementations of the parser's
            member functions. It is the only header file that is included by
            the source file containing <em >parse</em>'s implementation. User
            defined implementation of other class members may use the same
            convention, thus concentrating all directives and declarations
            that are required for the compilation of other source files
            belonging to the parser class in one header file.
<p>
<li> <strong >--implementation-skeleton</strong>=<em >pathname</em> (<strong >-I</strong>)<br/>
           <em >Pathname</em> defines the path name to the file containing the
            skeleton of the implementation header. t defaults to the
            installation-defined default path name (e.g.,
            <em >/usr/share/bisonc++/</em> plus <em >bisonc++.ih</em>).
<p>
<li> <strong >--insert-stype</strong><br/>
           This option is only effective if the <em >debug</em> option (or
            <em >%debug</em> directive) has been specified. When <em >insert-stype</em>
            has been specified the parsing function's debug output also shows
            selected semantic values. It should only be used if objects or
            variables of the semantic value type <em >STYPE__</em> can be inserted
            into <em >ostreams</em>.
<p>
<li> <a name="MAXDEPTH"></a> <strong >--max-inclusion-depth</strong>=<em >value</em><br/>
           Set the maximum number of nested grammar files. Defaults to 10.
<p>
<li> <strong >--namespace</strong> <em >identifier</em> <br/>
           Define all of the code generated by <strong >bisonc++</strong> in the namespace
            <em >identifier</em>. By default no namespace is defined. If this
            options is used the implementation header is provided with a
            commented out <em >using namespace</em> declaration for the specified
            namespace. In addition, the parser and parser base class
            header files also use the specified namespace to define their
            include guard directives.
<p>
It is an error if this option is used and an already existing
            parser-class header file and/or implementation header file does
            not define <em >namespace identifier</em>.
<p>
<li> <strong >--no-baseclass-header</strong><br/>
           Do not write the file containing the parser class' base class, even
            if that file doesn't yet exist. By default the file containing the
            parser's base class is (re)written each time <strong >bisonc++</strong> is called. Note
            that this option should normally be avoided, as the base class
            defines the symbolic terminal tokens that are returned by the
            lexical scanner. When the construction of this file is suppressed,
            modifications of these terminal tokens are not communicated to the
            lexical scanner.
<p>
<li> <strong >--no-decoration</strong> (<strong >-D</strong>)<br/>
           Do not include user-defined or default actions when generating the
            parser's <em >parse</em> member. This effectively generates a parser
            which merely performs syntax checks, without performing the
            actions which are normally executed when rules have been
            matched. This may be useful in situations where a (partially or
            completely) decorated grammar is reorganized, and the syntactic
            correctness of the modified grammar must be verified, or in
            situations where the grammar has already been decorated, but
            functions which are called from the rules's actions have not yet
            been impleemented.
<p>
<li> <strong >--no-lines</strong><br/> 
           Do not put <em >#line</em> preprocessor directives in the file containing
            the parser's <em >parse</em> function. By default the file containing
            the parser's <em >parse</em> function also contains <em >#line</em>
            preprocessor directives. This option allows the compiler and
            debuggers to associate errors with lines in your grammar
            specification file, rather than with the source file containing
            the <em >parse</em> function itself.
<p>
<li> <strong >--no-parse-member</strong><br/>
           Do not write the file containing the parser's predefined parser
            member functions, even if that file doesn't yet exist. By default
            the file containing the parser's <em >parse</em> member function is
            (re)written each time <strong >bisonc++</strong> is called. Note that this option
            should normally be avoided, as this file contains parsing
            tables which are altered whenever the grammar definition is
            modified. 
<p>
<li> <strong >--own-debug</strong><br/>
           Displays the actions performed by <strong >bisonc++</strong>'s parser when it processes
            the grammar specification <strong >s</strong> (lots of output!). This implies
            the <em >--verbose</em> option.
<p>
<li> <strong >--own-tokens</strong> (<strong >-T</strong>)<br/>
           The tokens returned as well as the text matched by <strong >bisonc++</strong>'s lexcial
            scanner are shown when this option is used.
<p>
This option does <em >not</em> result in the <em >generated</em> parsing
            function displaying returned tokens and matched text. If that is
            what you want, use the <em >--print-tokens</em> option.
<p>
<li> <strong >--parsefun-skeleton</strong>=<em >pathname</em> (<strong >-P</strong>)<br/>
           <em >Pathname</em> defines the path name of the file containing the
            parsing member function's skeleton. It defaults to the
            installation-defined default path name (e.g.,
            <em >/usr/share/bisonc++/</em> plus <em >bisonc++.cc</em>).
<p>
<li> <strong >--parsefun-source</strong>=<em >filename</em> (<strong >-p</strong>)<br/>
           <em >Filename</em> defines the name of the source file to contain the
            parser member function <em >parse</em>. Defaults to <em >parse.cc</em>.
<p>
<li> <strong >--polymorphic-code-skeleton</strong>=<em >pathname</em> (<strong >-L</strong>)<br/>
           <em >Pathname</em> defines the path name of the file containing the
            non-template members of the polymorphic Base class.  It defaults
            to the installation-defined default path name (e.g.,
            <em >/usr/share/bisonc++/</em> plus <em >bisonc++polymorphic</em>).
<p>
<li> <strong >--polymorphic-skeleton</strong>=<em >pathame</em> (<strong >-M</strong>)<br/>
           <em >Pathname</em> defines the path name of the file containing the
            skeleton of the polymorphic template classes. It defaults to the
            installation-defined default path name (e.g.,
            <em >/usr/share/bisonc++/</em> plus <em >bisonc++polymorphic.code</em>).
<p>
<li> <strong >--print-tokens</strong> (<strong >-t</strong>)<br/>
           The generated parsing function implements a function <em >print__</em>
            displaying (on the standard output stream) the tokens returned by
            the parser's scanner as well as the corresponding matched
            text. This implementation is suppressed when the parsing function
            is generated without using this option. The member <em >print__</em> is
            called from <em >Parser::print</em>, which is defined in-line in the the
            parser's class header. Calling <em >Parser::print__</em> can thus easily
            be controlled from <em >print</em>, using, e.g., a variable that set by
            the program using the parser generated by <strong >bisonc++</strong>.
<p>
This option does <em >not</em> show the tokens returned and text matched
            by <strong >bisonc++</strong> itself when it is reading its input <strong >s</strong>. If
            that is what you want, use the <em >--own-tokens</em> option.
<p>
<li> <a name="REQUIRED"></a> <strong >--required-tokens</strong>=<em >number</em><br/>
           Following a syntactic error, require at least <em >number</em>
            successfully processed tokens before another syntactic error can
            be reported. By default <em >number</em> is zero.
<p>
<li> <a name="SCANOPT"></a> <strong >--scanner</strong>=<em >pathname</em> (<strong >-s</strong>)<br/>
           <em >Pathname</em> defines the path name to the file defining the
            scanner's class interface (e.g., <em >"../scanner/scanner.h"</em>). When
            this option is used the parser's member <em >int lex()</em> is
            predefined as
           <pre>

    int Parser::lex()
    {
        return d_scanner.lex();
    }
                
</pre>

           and an object <em >Scanner d_scanner</em> is composed into the parser
            (but see also option <em >scanner-class-name</em>). The example shows
            the function that's called by default. When the <em >--flex</em> option
            (or <em >%flex</em> directive) is specified the function
            <em >d_scanner.yylex()</em> is called. Any other function to call can be
            specified using the <em >--scanner-token-function</em> option (or
            <em >%scanner-token-function</em> directive).
<p>
By default <strong >bisonc++</strong> surrounds <em >pathname</em> by double quotes (using,
            e.g., <em >#include "pathname"</em>).  When <em >pathname</em> is surrounded
            by pointed brackets <em >#include &lt;pathname&gt;</em> is included.
<p>
It is an error if this option is used and an already existing
            parser class header file does not include <em >`pathname'</em>.
<p>
<li> <strong >--scanner-class-name</strong> <em >scannerClassName</em> <br/> 
           Defines the name of the scanner class, declared by the <em >pathname</em>
            header file that is specified at the <em >scanner</em> option or 
            directive. By default the class name <em >Scanner</em> is used.
<p>
It is an error if this option is used and either the
            <em >scanner</em> option was not provided, or the parser class interface
            in an already existing parser class header file does not declare a
            scanner class <em >d_scanner</em> object.
<p>
<li> <strong >--scanner-debug</strong><br/> 
           Show de scanner's matched rules and returned tokens. This
            extensively displays the rules and tokens matched and returned by
            <strong >bisonc++</strong>'s scanner, instead of just showing the tokens and matched
            text which are received by <strong >bisonc++</strong>. If you want the latter, use the
            option <em >--own-tokens</em>.
<p>
<li> <strong >--scanner-matched-text-function</strong>=<em >function-call</em><br/> 
           The scanner function returning the text that was matched at the
            last call of the scanner's token function. A complete function
            call expression should be provided (including a scanner object, if
            used). This option overrules the <em >d_scanner.matched()</em> call used
            by default when the <em >%scanner</em> directive is specified, and it
            overrules the <em >d_scanner.YYText()</em> call used when the <em >%flex</em>
            directive is provided. Example:
           <pre>

    --scanner-matched-text-function "myScanner.matchedText()"
                
</pre>

<p>
<li> <strong >--scanner-token-function</strong>=<em >function-call</em><br/> 
           The scanner function returning the next token, called from the
            parser's <em >lex</em> function. A complete function
            call expression should be provided (including a scanner object, if
            used). This option overrules the <em >d_scanner.lex()</em> call used
            by default when the <em >%scanner</em> directive is specified, and it
            overrules the <em >d_scanner.yylex()</em> call used when the <em >%flex</em>
            directive is provided. Example:
           <pre>

    --scanner-token-function "myScanner.nextToken()"
                
</pre>

<p>
It is an error if this option is used and the scanner token
            function is not called from the code in an already
            existing implementation header.
<p>
<li> <strong >--show-filenames</strong><br/> 
           Writes the names of the generated files to the standard error
            stream.
<p>
<li> <strong >--skeleton-directory</strong>=<em >directory</em> (<strong >-S</strong>)<br/> 
           Specifies the directory containing the skeleton files. In addition
            to specifying a common names for the skeleton files the locations
            of individual skeleton files can be specified using the options
            (<em >-B -C, -H, -I, -L</em> and <em >-M</em>).
<p>
<li> <strong >--tag-mismatches</strong> <em >off|on</em><br/>
           When <em >on</em> is specified (which is the default), a warning is
            issued if no $$ assignment was detected in an action block, or if
            adding a default $$ = ... action was suppressed (cf.  the
            <em >default-actions off</em> option or directive).
<p>
<li> <strong >--target-directory</strong>=<em >pathname</em> <br/> 
           <em >Pathname</em> defines the directory where generated files should be
            written.  By default this is the directory where <strong >bisonc++</strong> is
            called. 
<p>
<li> <strong >--thread-safe</strong><br/> 
           No static data are modified, making <strong >bisonc++</strong> thread-safe.
<p>
<li> <strong >--usage</strong><br/>
            Writes basic usage information to the standard output stream and
            terminates. 
<p>
<li> <strong >--verbose</strong> (<strong >-V</strong>)<br/> 
           Writes a file containing verbose descriptions of the parser states
            and what is done for each type of look-ahead token in that state.
            This file also describes all conflicts detected in the grammar,
            both those resolved by operator precedence and those that remain
            unresolved.  It is not created by default, but if requested the
            information is written on <em >&lt;grammar&gt;.output</em>, where
            <em >&lt;grammar&gt;</em> is the grammar specification file passed to <strong >bisonc++</strong>.
<p>
<li> <strong >--version</strong> (<strong >-v</strong>)<br/>
            Displays <strong >bisonc++</strong>'s version number and terminates.
<p>
</ul>
<p>
<h2 >QUICK START</h2>
<p>
<strong >Bisonc++</strong> should be used as follows:
    <ul>
    <li> As usual, a grammar must be defined. With <strong >bisonc++</strong> this is not
different, and the reader is referred to <strong >bisonc++</strong>'s manual and other sources
(like Aho, Sethi and Ullman's book) for details about how to specify and
decorate grammars.
    <li> As noted, no `macro style' <em >%define</em> declarations are required
anymore. Instead, the normal practice of defining class members in source
files and declaring them in a class header files can be adhered to using
<strong >bisonc++</strong>.  Basically, <strong >bisonc++</strong> concentrates on its main tasks: defining a
parser class and implementing its parsing function <em >int parse</em>,
leaving all other parts of the parser class' definition to the programmer.
    <li> Having specified the grammar and (usually) some directives <strong >bisonc++</strong> is
run, generating the essential elements of a parser class. See the next section
for details about the various files that are generated by <strong >bisonc++</strong>.
    <li> Any members that are required in addition to the <strong >bisonc++</strong>-generated
member <em >parse</em> and its support functions must be implemented by the
programmer and declared in the parser's class header.  At the very least a
member <em >int lex</em> must be defined (a default 
implementation can be generated by <strong >bisonc++</strong>). 
    <li> The generated parser can now be used in a program. A very simple
example would be:
        <pre>

    int main()
    {
        Parser parser;
        return parser.parse();
    }
        
</pre>

    </ul>
<p>
<h2 >GENERATED FILES</h2>
<p>
<strong >Bisonc++</strong> may create the following files:
    <ul>
    <li> A file containing the implementation of the member function <em >parse</em>
and its support functions. The member <em >parse</em> is a public member that can be
called to parse a token-sequence according to a specified LALR1 type of
grammar. By default the implementations of these members are written on the
file <em >parse.cc</em>. The programmer should not modify the contents of this file;
it is rewritten every time <strong >bisonc++</strong> is called.
    <li> A file containing an initial setup of the parser class, containing
the declaration of the public member <em >parse</em> and of its (private) support
members. New members may safely be declared in the parser class, as it is only
created by <strong >bisonc++</strong> if not yet existing, using the filename <em >&lt;parser-class&gt;.h</em>
(where <em >&lt;parser-class&gt;</em> is the the name of the defined parser class).
        <li> A file containing the parser class' <em >base class</em>. This base
class should not be modified by the programmer. It contains types defined by
<strong >bisonc++</strong>, as well as several (protected) data members and member functions, which
should not be redefined by the programmer. All symbolic parser terminal tokens
are defined in this class, thereby escalating these definitions to a separate
class (cf. Lakos, (2001)), which in turn prevents circular dependencies
between the lexical scanner and the parser (here, circular dependencies may
easily be encountered, as the parser needs access to the lexical scanner class
when defining the lexical scanner as one of its data members, whereas the
lexical scanner needs access to the parser class to know about the grammar's
symbolic terminal tokens; escalation is a way out of such circular
dependencies). By default this file is (re)written any time <strong >bisonc++</strong> is called,
using the filename <em >&lt;parser-class&gt;base.h</em>.
        <li> A file containing an <em >implementation header</em>. The
implementation header rather than the parser's class header file should be
included by the parser's source files implementing member functions declared
by the programmer. The implementation header first includes the parser class's
header file, and then provides default in-line implementations for its members
<em >error</em> and <em >print</em> (which may be altered by the programmer). The member
<em >lex</em> may also receive a standard in-line implementation. Alternatively, its
implementation can be provided by the programmer (see below).  Any directives
and/or namespace directives required for the proper compilation of the
parser's additional member functions should be declared next. The
implementation header is included by the file defining <em >parse</em>. By default
the implementation header is created if not yet existing, receiving the
filename <em >&lt;parser-class&gt;.ih</em>.
        <li> A verbose description of the generated parser. This file is
comparable to the verbose output file originally generated by <strong >bison++</strong>. It
is generated when the option <em >--verbose</em> or <em >-V</em> is provided. If so, <strong >bisonc++</strong>
writes the file <em >&lt;grammar&gt;.output</em>, where <em >&lt;grammar&gt;</em> is the name of the
file containing the grammar definition.
        </ul>
<p>
<h2 >FILES</h2>
    <ul>
    <li> <strong >bisonc++base.h</strong>: skeleton of the parser's base class;
    <li> <strong >bisonc++.h</strong>: skeleton of the parser class;
    <li> <strong >bisonc++.ih</strong>: skeleton of the implementation header;
    <li> <strong >bisonc++.cc</strong>: skeleton of the member <em >parse</em>;
    <li> <strong >bisonc++polymorphic</strong>: skeleton of the declarations used by
        <em >%polymorphic</em>;
    <li> <strong >bisonc++polymorphic.code</strong>: skeleton of the non-inline
        implementations of the members declared in <strong >bisonc++polymorphic</strong>.
    <li> <strong >debugdecl.in</strong>: skeleton declaring members of the parser's base
        class that are only required when the <em >debug</em> option or directive
        was specified.
    <li> <strong >debugfunctions1.in</strong>: skeleton defining the members declared in
        <em >debugdecl.in</em>.
    <li> <strong >debugfunctions2.in</strong>: skeleton implementing <em >symbol__</em>, which is
        only needed when the <em >print-tokens</em> option or directive was
        specified. 
    <li> <strong >debugfunctions3.in</strong>: skeleton implementing <em >errorVerbose__</em>,
        which is only needed when the <em >error-verbose</em> option or directive was
        specified.
    <li> <strong >debugincludes.in</strong>: skeleton specifying the header files
        <em >#include</em> directives that are required  when the <em >debug</em> option
        or directive was specified.
    <li> <strong >debuglookup.in</strong>: skeleton containing extra code required in the
        <em >Parser::lookup</em> member when the <em >debug</em> option of directive was
        specified.
    <li> <strong >lex.in</strong>: skeleton implementing the <em >Parser::lex</em> function.
    <li> <strong >ltypedata.in</strong>: skeleton declaring the location variables
    <li> <strong >ltype.in</strong>: skeleton defining the default or user defined
        <em >LTYPE__</em>.
    <li> <strong >print.in</strong>: skeleton implementing the actions of <em >Parser::print</em>
        if the <em >print-tokens</em> option or directive was specified.
    <li> <strong >threading.in</strong>: skeleton defining the variables required for
        generating a thread-safe parsing function.
    </ul>
<p>
<h2 >SEE ALSO</h2>
        <strong >bison</strong>(1), <strong >bison++</strong>(1), 
    <strong >bison++api</strong>(3), <strong >bison++input</strong>(7), 
    <strong >bison.info</strong> (using texinfo),
    <strong >flexc++</strong>(1),
    <strong >https://fbb-git.github.io/bisoncpp/</strong>
<p>
Lakos, J. (2001) <strong >Large Scale C++ Software Design</strong>, Addison Wesley.<br/>
    Aho, A.V., Sethi, R., Ullman, J.D. (1986) <strong >Compilers</strong>, Addison Wesley.
<p>
<h2 >BUGS</h2>
<p>
Parser-class header files (e.g., Parser.h) and parser-class internal
    header files (e.g., Parser.ih) generated with bisonc++ &lt; 4.02.00 require
    two hand-modifications when used in combination with bisonc++ &gt;=
    4.02.00. See the description of <em >exceptionHandler__</em> for details.
<p>
Discontinued options:
    <ul>
        <li> <strong >--include-only</strong>
        <li> <strong >--namespace</strong>
        <li> <strong >--polymorphic-inline-skeleton</strong>
    </ul>
<p>
To avoid collisions with names defined by the parser's (base) class, the
following identifiers should not be used as token names:
    <ul>
    <li> Identifiers ending in two underscores;
    <li> Any of the following identifiers: <em >ABORT, ACCEPT, ERROR, clearin,
        debug, error</em>, or <em >setDebug</em>.
    </ul>
<p>
When re-using files generated by <strong >bisonc++</strong> before version 2.0.0, minor
hand-modification may be necessary.  Refer to <strong >bisonc++</strong>'s git
(https://github.com/fbb-git/bisoncpp) for details.
<p>
The <em >Semantic</em> parser, mentioned in <strong >bison++</strong>(1) is not implemented in
<strong >bisonc++</strong>(1). According to <strong >bison++</strong>(1) the semantic parser was not
available in <strong >bison++</strong> either. Maybe a so-called <em >pure</em> parser is
available through the <em >--thread-safe</em> option.
<p>
<h2 >ABOUT bisonc++</h2>
<p>
<strong >Bisonc++</strong> was based on <strong >bison++</strong>, originally developed by Alain
Coetmeur (coetmeur@icdc.fr), R&amp;D department (RDT), Informatique-CDC, France,
who based his work on <strong >bison</strong>, GNU version 1.21. 
<p>
<strong >Bisonc++</strong> version 0.98 and beyond is a complete rewrite of an LALR-1 parser
generator, closely following the construction process as described in Aho,
Sethi and Ullman's (1986) book <strong >Compilers</strong> (i.e., the <em >Dragon book</em>).  It
uses the same grammar specification as <strong >bison</strong> and <strong >bison++</strong>, and it uses
practically the same options and directives as <strong >bisonc++</strong> versions earlier than
0.98. Variables, declarations and macros that are obsolete were removed. 
<p>
Compared to <em >bison</em> and <em >bison++</em>, the number and functions of the
various <em >%define</em> declarations was thoroughly modified. All of
<em >bison's %define</em> declarations were replaced by their (former) first
arguments. Furthermore, `macro-style' declarations are not supported or
required. Finally, all directives only use lower-case characters and do not
contain underscore characters (but sometimes hyphens). E.g., <em >%define DEBUG</em>
is now declared as <em >%debug</em>; <em >%define LSP_NEEDED</em> is now declared as
<em >%lsp-needed</em> (note the hyphen).
<p>
<h2 >AUTHOR</h2>
<p>
Frank B. Brokken (f.b.brokken@rug.nl).
<p>
